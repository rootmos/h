#!/usr/bin/env python3

import argparse
import datetime
import json
import logging
import os
import signal
import subprocess
import sys
import tempfile

TOOLS = os.environ.get("TOOLS", os.path.dirname(os.path.realpath(__file__)))
CAPTURE = os.environ.get("CAPTURE", os.path.join(TOOLS, "capture"))
WATCH = os.environ.get("WATCH", os.path.join(TOOLS, "strace-log-watch"))

def parse_args():
    parser = argparse.ArgumentParser(description="Yet another test runner")

    parser.add_argument("--log", default=os.environ.get("LOG_LEVEL", "WARN"), help="set log level")

    parser.add_argument("-s", "--silent", action="store_true")
    parser.add_argument("-t", "--trace", action="store_true", default=os.environ.get("TRACE") != None)

    parser.add_argument("-T", "--timeout", type=int, default=os.environ.get("TIMEOUT"))

    parser.add_argument("-o", "--output", default=os.environ.get("OUTPUT"))

    parser.add_argument("input", metavar="INPUT")

    return parser.parse_args()

logger = None
def setup_logger(level):
    l = logging.getLogger("test-runner")
    l.setLevel(level)

    ch = logging.StreamHandler()
    ch.setLevel(level)

    f = logging.Formatter(
        fmt="%(asctime)s:%(name)s:%(levelname)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z")
    ch.setFormatter(f)

    l.addHandler(ch)

    return l

if __name__ == "__main__":
    args = parse_args()
    logger = setup_logger(args.log.upper())
    logger.debug(f"args: {args}")

    fn = args.input

    if os.path.isdir(fn):
        test_metafile = os.environ.get("TEST_METAFILE", "test.json")
        fn = os.path.join(fn, test_metafile)
    logger.info(f"test file: {fn}")

    with open(fn, "r") as f:
        t = json.load(f)
    logger.debug(f"test spec: {t}")

    res = {}

    res["root"] = root = os.path.dirname(fn)
    logger.debug(f"test root: {root}")

    name = t.get("name")
    if name is None:
        name = os.path.basename(root)
    res["name"] = name
    logger.debug(f"test name: {name}")

    project_root = os.environ.get("PROJECT_ROOT")
    if project_root is None:
        project_root = os.path.realpath(os.path.dirname(os.path.dirname(root)))
    res["project_root"] = project_root
    res["project"] = os.environ.get("PROJECT", os.path.basename(project_root))

    sut = os.environ.get("SUT")
    if sut is None:
        exe = os.environ.get("EXE")
        if exe is None:
            exe = os.path.basename(project_root)

        sut = os.path.join(project_root, exe)
    res["sut"] = sut
    logger.debug(f"test sut: {sut}")

    input_ = os.path.realpath(os.path.join(root, t.get("input")))
    res["input"] = input_
    logger.debug(f"test input: {input_}")

    with tempfile.TemporaryDirectory() as tmp:
        stdout = os.path.join(tmp, "stdout")
        stderr = os.path.join(tmp, "stderr")
        returncode = os.path.join(tmp, "returncode")

        cmdline = [CAPTURE, "-o", stdout, "-e", stderr, "-r", returncode]
        if args.silent:
            cmdline += ["-O", "-E"]
        cmdline += ["--"]

        if args.trace:
            trace = os.path.join(tmp, "trace")
            cmdline += [
                "strace",
                "--absolute-timestamps=precision:us",
                "--follow-forks", "--output-separately",
                "--output", trace,
            ]
        else:
            trace = None

        cmdline += [sut]
        cmdline += t.get("args", [])
        cmdline += [input_]

        res["cmdline"] = cmdline
        res["when"] = datetime.datetime.now().astimezone().isoformat(timespec="seconds")
        p = subprocess.Popen(cmdline, cwd=root)

        if trace and not args.silent:
            w = subprocess.Popen([WATCH, "-p", str(p.pid), trace])
        else:
            w = None

        res["result"] = True
        res["messages"] = []
        try:
            p.wait(timeout=args.timeout)

            with open(returncode, "r") as f:
                res["returncode"] = int(f.read())
            expected_exit = t.get("exit", 0)
            if isinstance(expected_exit, str):
                expected_exit = -int(signal.__dict__[expected_exit])
            res["expected_returncode"] = expected_exit
        except subprocess.TimeoutExpired:
            res["timeout"] = args.timeout
            res["result"] = False
            res["messages"].append("process timedout")

        if w is not None:
            w.wait()

        with open(stdout, "rb") as f:
            res["stdout"] = f.read().decode("UTF-8")
        with open(stderr, "rb") as f:
            res["stderr"] = f.read().decode("UTF-8")

        if trace:
            q = subprocess.run(["strace-log-merge", trace], capture_output=True, check=True)
            res["trace"] = q.stdout.decode("UTF-8")

    expected_stdout_fn = t.get("stdout")
    if expected_stdout_fn is None:
        expected_stdout_fn = os.path.join(root, "stdout")
        if not os.path.exists(expected_stdout_fn):
            expected_stdout_fn = None
    if expected_stdout_fn is not None:
        logger.debug(f"expected stdout from: {expected_stdout_fn}")
        res["expected_stdout_fn"] = expected_stdout_fn

        with open(expected_stdout_fn, "rb") as f:
            res["expected_stdout"] = f.read().decode("UTF-8")
    else:
        expected_stdout = None

    if "returncode" in res and res["returncode"] != expected_exit:
        res["result"] = False
        res["messages"].append("unexpected exit status")

    if "expected_stdout" in res and res["expected_stdout"] != res["stdout"]:
        res["result"] = False
        res["messages"].append("stdout mismatch")

    if args.output:
        with open(args.output, "w") as f:
            f.write(json.dumps(res))

    sys.exit(0 if res["result"] else 1)
